module SlcUtil
import Statistics
import Images
import Colors

using PyCall
scipy_interp = pyimport("scipy.interpolate");


export SlcRaw, show_img, original_view, footprint, phase_ramp


"""
    get_burst_corners(burst_number::Int, meta::Dict)

Computes the corner indices of a burst.

# Arguments
- `burst_number::Int`: The number of the burst of interest.
- `meta::Dict`:  Meta information from the Sentinel-1 SLC image

# Output

# Examples:
```jldoctest
julia> meta = Load.slc_meta(path_meta_1);
julia> burst_number = 1
julia> first_index_row, last_index_row, first_index_col, last_index_col = get_burst_corners(burst_number, meta)
julia> print(first_index_row, ", ",last_index_row, ", ",first_index_col, ", ",last_index_col)
32, 1495, 946, 24512
```
"""
function get_burst_corners(burst_number, meta)
    first_index_row = findfirst(x->x!=-1, meta["burst_meta"]["fist_valid_pixel"][burst_number])
    last_index_row = findlast(x->x!=-1, meta["burst_meta"]["last_valid_pixel"][burst_number])
    first_index_col = meta["burst_meta"]["fist_valid_pixel"][burst_number][first_index_row]
    last_index_col = meta["burst_meta"]["last_valid_pixel"][burst_number][last_index_row]
    return first_index_row, last_index_row, first_index_col, last_index_col
end



"""
    deramp(burst_number::Int, meta::Dict, precise_orbit:Dict)

Computes the phase ramp (phi) for the given burst number for input lines and samples.

# Arguments
- `line::Array{Int,1}`: The lines of interest.
- `sample::Array{Int,1}`: The samples of interest.
- `burst_number::Int`: The number of the burst of interest.
- `meta::Dict`:  Meta information from the Sentinel-1 SLC image
- `v_mid:Dict`: Satellite speed at mid burst time

# Output
- ramp::Array{Float64,1}: Array with deramped phase for line and sample

# Examples:
```jldoctest
julia> meta = Load.slc_meta(path_meta_1);
julia> precise_orbit = Load.precise_orbit(path_pod_1, meta["t_0"]);
julia> burst_number = 1
julia> phase = deramp(burst_number, meta, precise_orbit);
1525×23567 Array{Float64,1}:
 6.17566e8  6.17565e8  6.17564e8  …  5.89003e8  5.89001e8  5.89e8
```

#Notes
Equation reference: Miranda, 2017: "Definition of the TOPS SLC deramping function for products generated by the S-1 IPF"
"""
function phase_ramp(lines, samples, burst_number, meta, v_mid)
    # fish out constants and parameters
    c = 299792458
    k_psi = meta["azimuth_steering_rate"] * pi/180
    dc_coef = meta["burst_meta"]["data_dc_polynomial"][burst_number, :]
    dc_tau0 = meta["burst_meta"]["data_dc_t0"][burst_number]
    fm_coef = meta["burst_meta"]["azimuth_fm_rate_polynomial"][burst_number, :]
    fm_tau0 = meta["burst_meta"]["azimuth_fm_rate_t0"][burst_number]
    f_c = meta["radar_frequency"]
    lines_per_burst = meta["lines_per_burst"]
    number_of_samples = meta["number_of_samples"]
    Delta_t_s = meta["azimuth_time_interval"]
    Delta_tau_s = 1/meta["range_sampling_rate"]
    tau_0 = meta["slant_range_time"]
    v_s = v_mid

    # Not sure about tau0 in tau_mid
    k_a(x, fm_param, x0) = fm_param[1] .+ fm_param[2].*(x .- x0) .+ fm_param[3].*(x .- x0).^2 # Doppler FM rate, Eqn. 11
    f_etac(x, dc_param, x0) = dc_param[1] .+ dc_param[2].*(x .- x0) .+ dc_param[3].*(x .- x0).^2; # Doppler centroid freq Eqn. 13

    tau = tau_0 .+ (samples .- 1) .* Delta_tau_s # Slant range time of ith sample, Eqn. 12

    # Doppler rate equations
    k_s = 2 * v_s/c * f_c * k_psi; # Doppler rate from antenna scanning, Eqn. 4
    alpha = 1 .- k_s ./ k_a(tau, fm_coef, fm_tau0); # conversion factor, Eqn. 3
    k_t = k_s ./ alpha; # Doppler Centroid Rate, Eqn. 2

    # Doppler azimuth time equations
    eta_c = - f_etac(tau, dc_coef, dc_tau0) ./ k_a(tau, fm_coef, fm_tau0); # Beam centre crossing time, Eqn. 7
    tau_mid = tau_0 + number_of_samples/2 * Delta_tau_s

    eta_ref = eta_c .- (- f_etac(tau_mid, dc_coef, dc_tau0)/k_a(tau_mid, fm_coef, fm_tau0)); # Reference time, Eqn. 6
    line_in_burst = lines .- lines_per_burst*(burst_number-1)
    eta = -lines_per_burst/2*Delta_t_s .+ (line_in_burst .- 1/2 ) .* Delta_t_s

    # Compute the phase ramp added the modulation term
    ramp = pi * k_t .* (eta .- eta_ref).^2 .+ 2 * pi .* f_etac(tau, dc_coef, dc_tau0) .* (eta .- eta_ref); # Eqn. 14
    return ramp
end



## Structs

"""
    SlcRaw(view, meta, data)

    # Arguments
    - `view::Array{UnitRange,1}`: view defines the subset of the .tiff in data
    - `meta::Dict`: Annotations as a Dict
    - `data::Array{Complex,2}`: Complex pixel values
"""
struct SlcRaw
    view::Array{UnitRange,1}
    meta::Dict
    data::Array{Complex,2}
end

## oveload
function Base.:show(io::IO, img::SlcRaw)
    represent = "SlcRaw::"
    represent *= " " *  img.meta["mission_id"]
    represent *= "-" * img.meta["mode"]
    represent *= "-" * img.meta["polarisation"]
    represent *= "-" * "Swath" * string(img.meta["swath"])
    represent *= " " * string(img.meta["t_0"])
    represent *= " " * "View:[" * string(img.view[1]) * "," * string(img.view[2]) * "]"
    print(io,represent)
end

function Base.:size(img::SlcRaw)
    return size(img.data)
end

function Base.:size(img::SlcRaw,dim)
    return size(img.data,dim)
end

"""
    img[I1,I2]

    Slice ::SlcRaw like an array.

    !!!!!!!
    The keyword end and "open" slice does not work eg.
    [5:end] and [5:].

    Use instead:
    img[5:size(img,1),5:size(img,2)]
    !!!!!!!!
"""
function Base.:getindex(img::SlcRaw,I1::UnitRange{Int}, I2::UnitRange{Int})
    # slice data
    data = img.data[I1,I2]

    # update view
    delta_1 = I1.stop-I1.start
    delta_2 = I2.stop-I2.start
    view_1_start =  (img.view[1].start + I1.start-1)
    view_2_start =  (img.view[2].start + I2.start-1)
    view = [view_1_start:(view_1_start+delta_1),view_2_start:(view_2_start+delta_2)]

    # return sliced SclRaw
    return SlcRaw(view, img.meta, data)
end


## utilitize

"""
    show_img(img,max_quantile=0.98)

    Scales images and show it using Image.Gray()
"""
function show_img(img,max_quantile=0.98)
    return Images.Gray.(abs.(img)./Statistics.quantile(reshape(abs.(img), :), max_quantile))
end
function show_img(img::SlcRaw,max_quantile=0.98)
    return show_img(img.data,max_quantile)
end


"""
    original_view(s1_ann)

    Get the view of the entire tiff file associated with the annotations
    "s1_ann"
"""
function original_view(s1_ann)
    return [1:(s1_ann["lines_per_burst"]*s1_ann["burst_count"]),1:s1_ann["samples_per_burst"]]
end
function original_view(img::SlcRaw)
    return original_view(img.meta)
end


"""
    _raw_coords(s1_ann,line,sample)

    Gives approximated coordinates for line,sample
"""
function _raw_coords(s1_ann,line,sample)
    scipy_interp = PyCall.pyimport("scipy.interpolate");
    line_goepoints = s1_ann["geolocation"]["line"]
    sample_goepoints = s1_ann["geolocation"]["sample"]
    latitude_goepoints = s1_ann["geolocation"]["latitude"]
    longitude_goepoints = s1_ann["geolocation"]["longitude"]


    point_latitude = scipy_interp.griddata(hcat(line_goepoints,sample_goepoints),
                                            latitude_goepoints, (line,sample), method="linear")
    point_logitude = scipy_interp.griddata(hcat(line_goepoints,sample_goepoints),
                                            longitude_goepoints, (line,sample), method="linear")

    return point_latitude,point_logitude
end

"""
    footprint(s1_ann,view)

    Gives APPROXIMATED coordinates for the footprint based on
    the geolocations in the annotaions.

    !!!
    Theses coordinates can easily be 100 pixels off
    !!!
"""
function footprint(s1_ann,view)
    # Get corners
    line = [view[1].start,view[1].stop,view[1].stop,view[1].start]
    sample = [view[2].start,view[2].start,view[2].stop,view[2].stop]
        return _raw_coords(s1_ann,line,sample)
end
function footprint(img::SlcRaw)
    return footprint(img.meta,img.view)
end


"""
    mosaic_view(s1_ann,view)

    Gives the view in mosaic geometry (same as sali).
    Mosaic geometry is when the lines are counted from the first
    burst and with equal spacing. It correospond to collapsing all overlapping
    lines. Sample range is the same
"""
function mosaic_view(s1_ann,view)
    # get info
    start_line = view[1].start
    end_line = view[1].stop
    lines_per_burst = s1_ann["lines_per_burst"]
    mosaic_lines = s1_ann["burst_meta"]["first_line_mosaic"]

    # Find start line
    burst = Int(floor((start_line-1)/lines_per_burst))+1  # minus one because of 0 vs 1 index
    line_burst = start_line - (burst-1)*lines_per_burst
    mosaic_start = mosaic_lines[burst]+(line_burst-1)
    # Check the burst after has a line there is before the first burst
    if end_line > (burst*lines_per_burst)
        mosaic_start = minimum([mosaic_start,mosaic_lines[burst+1]])
    end

    # find end line
    burst = Int(floor((end_line-1)/lines_per_burst))+1  # minus one because of 0 vs 1 index
    line_burst = end_line - (burst-1)*lines_per_burst
    mosaic_stop = mosaic_lines[burst]+(line_burst-1)
    # Check the burst before has a line there is after the last burst
    if start_line < ((burst-1)*lines_per_burst)
        mosaic_stop = maximum([mosaic_stop,mosaic_lines[burst-1]+lines_per_burst-1])
    end

    return [mosaic_start:mosaic_stop,view[2]]
end
function mosaic_view(img::SlcRaw)
    mosaic_view(img.meta,img.view)
end


"""
    plot_phase(img)

    Plot a color image of the phase of img
    - `img::Array{Complex}`:
"""
function plot_phase(img)
    phase = (angle.(img) .+pi)./(2*pi)

    return Colors.RGB{Float32}.(1 .-phase.^2,4 .*(phase .-  phase.^2),phase.^2)
end


"""
    _phase_colorbar(n=17)

    Plot a color bar that fits  plot_phase(img)
"""
function _phase_colorbar(n=17)
    phase = 0:0.003:1
    display(Colors.RGB{Float32}.(1 .-phase.^2,4 .*(phase .-  phase.^2),phase.^2))
    println(" -π"*" "^n,"-π/2"*" "^n,"0"*" "^n,"π/2"*" "^n,"π")
end



end
